
### **سوال ۱: Explain the concept of reconciliation in React.**

  

**پاسخ:**

ری‌اکت از الگوریتم reconciliation برای تشخیص تفاوت بین Virtual DOM قبلی و جدید استفاده می‌کنه و تنها بخش‌های تغییر یافته رو در DOM واقعی اعمال می‌کنه. این الگوریتم به صورت بهینه و سریع مقایسه می‌کنه، اما فرض‌هایی هم داره (مثل اینکه key ها ثابت بمونن).

---

### **سوال ۲: تفاوت useMemo و useCallback در ری‌اکت؟**

  

**پاسخ:**

- useMemo: برای _memorize کردن مقدار_ برگشتی یک تابع
    
- useCallback: برای _memorize کردن خود تابع_
    
    هر دو برای جلوگیری از رندر یا محاسبه‌ی غیرضروری استفاده می‌شن.
    

---

### **سوال ۳: چرا و کِی از Context API استفاده می‌کنیم؟**

  

**پاسخ:**

برای اشتراک‌گذاری داده‌هایی مثل theme، user auth یا locale بین چند سطح از کامپوننت‌ها بدون نیاز به prop drilling. اما برای داده‌های زیاد یا تغییرات مکرر، Redux یا Zustand مناسب‌تره چون context باعث re-render وسیع می‌شه.

---

### **سوال ۴: تفاوت React.lazy و dynamic import؟**

  

**پاسخ:**

React.lazy مخصوص lazy load کردن **کامپوننت‌ها**ست و با Suspense استفاده می‌شه.

اما dynamic import() می‌تونه هر ماژولی رو به‌صورت async لود کنه، نه‌فقط کامپوننت.

---

### **سوال ۵: مفهوم render props چیه؟**

  

**پاسخ:**

روشی برای به اشتراک‌گذاری logic بین کامپوننت‌ها با استفاده از prop که تابع هست و UI رو از بیرون تعیین می‌کنه.

---

### **سوال ۶: تفاوت HOC و Custom Hook؟**

  

**پاسخ:**

- HOC: تابعی که یک کامپوننت رو می‌گیره و کامپوننتی با ویژگی‌های بیشتر برمی‌گردونه.
    
- Custom Hook: تابعی که از سایر hook ها استفاده می‌کنه و logic قابل reuse تولید می‌کنه.
    
    امروزه استفاده از custom hook توصیه می‌شه چون خواناتر و ساده‌تره.
    

---

### **سوال ۷: تفاوت بین useRef و useState؟**

  

**پاسخ:**

- useRef باعث تغییر UI نمی‌شه و مقدارش بین رندرها حفظ می‌شه.
    
- useState باعث رندر مجدد کامپوننت می‌شه.
    
    useRef مناسب نگه‌داری مقادیر “غیربصری” مثل تایمر یا DOM node هست.
    

---

### **سوال ۸: چه زمانی ری‌اکت رندر مجدد انجام می‌دهد؟**

  

**پاسخ:**

وقتی state یا props یک کامپوننت تغییر کند. اگر کامپوننت فرزند باشد و prop جدیدی دریافت کند نیز ممکن است دوباره render شود.

---

### **سوال ۹: چرا استفاده‌ی نادرست از key در map می‌تونه مشکل‌ساز بشه؟**

  

**پاسخ:**

اگر key مناسب (مثلاً index به‌صورت پویا) استفاده نشه، الگوریتم diffing اشتباه می‌کنه و باعث re-render غیرضروری یا از دست رفتن state داخلی می‌شه.

---

### **سوال ۱۰: تفاوت defer، async و بدون attribute برای اسکریپت؟**

  

**پاسخ:**

- async: موازی دانلود و اجرا، ولی ترتیب حفظ نمی‌شه
    
- defer: دانلود موازی، اجرا بعد از load شدن HTML
    
- بدون هیچ: اسکریپت به‌صورت بلوک‌کننده اجرا می‌شه
    

---

### **سوال ۱۱: چه تفاوتی بین debounce و throttle هست؟**

  

**پاسخ:**

- debounce: تا زمانی که event متوقف نشده، تابع اجرا نمی‌شه
    
- throttle: تابع در بازه‌های زمانی مشخص اجرا می‌شه حتی اگه event تکرار بشه
    

---

### **سوال ۱۲: تفاوت بین shallow و deep copy در جاوااسکریپت؟**

  

**پاسخ:**

Shallow فقط سطح اول object رو کپی می‌کنه، اما اشاره‌گرهای داخلی حفظ می‌شن.

Deep copy کل ساختار object رو بازسازی می‌کنه (مثلاً با structuredClone یا lodash cloneDeep).

---

### **سوال ۱۳: مشکلات رایج memory leak در اپ‌های ری‌اکتی؟**

  

**پاسخ:**

- استفاده از تایمر یا event listener که در useEffect پاک نشده
    
- نگه داشتن reference غیرضروری به object
    
- اشتباه در استفاده از closureها یا refها
    

---

### **سوال ۱۴: مفهوم hoisting چیست؟**

  

**پاسخ:**

تعاریف var، function به بالای scope منتقل می‌شن. اما let و const hoist می‌شن ولی تا قبل از تعریف قابل دسترسی نیستن (TDZ: Temporal Dead Zone).

---

### **سوال ۱۵: Symbol در جاوااسکریپت چیست؟**

  

**پاسخ:**

یک نوع داده primitive برای ساختن property های یونیک. قابل مشاهده در iteration نیستن. مناسب برای key‌هایی که collision نکنن.

---

### **سوال ۱۶: ماجرای stale closure در useEffect چیه؟**

  

**پاسخ:**

وقتی داخل useEffect به مقداری از state یا prop ارجاع داده بشه که داخل dependency array نیومده و مقدار قدیمی نگه داشته می‌شه، بهش می‌گن stale closure.

---

### **سوال ۱۷: چه زمانی باید از Error Boundary استفاده کنیم؟**

  

**پاسخ:**

برای گرفتن ارورهای runtime در lifecycle, render یا constructor کامپوننت‌های فرزند. در فانکشنال کامپوننت‌ها، هنوز راه مستقیمی نیست و باید از کلاس استفاده کرد.

---

### **سوال ۱۸: چه مشکلی با useEffect(async () => …) داریم؟**

  

**پاسخ:**

تابع useEffect نباید async باشه چون async باعث می‌شه که مقدار برگشتی Promise باشه که با ساختار cleanup ری‌اکت تداخل داره. به جای اون باید توش یک تابع async تعریف و فراخوانی بشه.

---

### **سوال ۱۹: تفاوت بین map و forEach چیه؟**

  

**پاسخ:**

- map مقدار جدید و آرایه‌ای برمی‌گردونه
    
- forEach فقط iteration انجام می‌ده و مقدار برگشتی نداره
    

---

### **سوال ۲۰: چطور می‌شه یک کمپوننت سنگین رو بهینه کرد؟**

  

**پاسخ:**

- استفاده از React.memo
    
- تقسیم کامپوننت به بخش‌های کوچک‌تر
    
- lazy loading
    
- استفاده از useMemo و useCallback
    
- جلوگیری از re-render غیرضروری با مقایسه props